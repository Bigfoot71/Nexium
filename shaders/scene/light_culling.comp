/* light_culling.comp -- Compute shader for culling light per cluster
 *
 * Copyright (c) 2025 Le Juez Victor
 *
 * This software is provided 'as-is', without any express or implied warranty.
 * For conditions of distribution and use, see accompanying LICENSE file.
 */

/* === Profile Specific === */

#ifdef GL_ES
precision highp float;
#endif

/* === Includes === */

#include "../include/frustum.glsl"
#include "../include/lights.glsl"

/* === Storage Buffers === */

/** 
 * sLights[] : list of active lights
 *   - MUST be sorted CPU-side: DIR -> SPOT -> OMNI
 *   - Shaders assume this order for sIndices and per-type offsets
 */
layout(std430, binding = 0) buffer LightBuffer {
    Light sLights[];
};

/** 
 * sClusters[] : per-cluster info
 *   - xyz = number of lights per type (numDir, numSpot, numOmni)
 *   - w   = unused
 */
layout(std430, binding = 1) buffer ClusterBuffer {
    uvec4 sClusters[];
};

/** 
 * sIndices[] : light indices per cluster
 *   - Indices into sLights[], grouped by type: DIR -> SPOT -> OMNI
 */
layout(std430, binding = 2) buffer IndexBuffer {
    uint sIndices[];
};

/** 
 * sClusterAABBs[] : AABBs for each cluster
 *   - Calculated during cluster culling in this compute shader
 *   - Can be reused in later passes
 */
layout(std430, binding = 3) buffer ClusterAABBBuffer {
    Cluster sClusterAABBs[];
};

/* === Uniform Buffers === */

layout(std140, binding = 0) uniform U_ViewFrustum {
    Frustum uFrustum;
};

/* === Uniforms === */

layout(location = 0) uniform uvec3 uClusterCount;
layout(location = 1) uniform float uClusterSliceScale;
layout(location = 2) uniform float uClusterSliceBias;

layout(location = 3) uniform uint uNumLights;
layout(location = 4) uniform uint uMaxLightsPerCluster;

/* === Helper Functions === */

void ClusterBounds(uvec3 clusterCoord, out vec3 minBounds, out vec3 maxBounds)
{
    // XY -> NDC
    vec2 texMin = vec2(clusterCoord.xy) / vec2(uClusterCount.xy);
    vec2 texMax = vec2(clusterCoord.xy + 1u) / vec2(uClusterCount.xy);
    vec2 ndcMin = texMin * 2.0 - 1.0;
    vec2 ndcMax = texMax * 2.0 - 1.0;

    // Z slice -> view space depth
    float zNearSlice = exp2((float(clusterCoord.z) - uClusterSliceBias) / uClusterSliceScale);
    float zFarSlice  = exp2((float(clusterCoord.z+1u) - uClusterSliceBias) / uClusterSliceScale);
    float viewZNear = -zNearSlice;
    float viewZFar  = -zFarSlice;

    // 4 corners in NDC (X,Y), Z = 1 because we'll rescale in view space
    vec4 ndcCorners[4] = vec4[4](
        vec4(ndcMin.x, ndcMin.y, 1.0, 1.0),
        vec4(ndcMax.x, ndcMin.y, 1.0, 1.0),
        vec4(ndcMin.x, ndcMax.y, 1.0, 1.0),
        vec4(ndcMax.x, ndcMax.y, 1.0, 1.0)
    );

    // Init bounds
    minBounds = vec3( 1e20);
    maxBounds = vec3(-1e20);

    // Helper
    for (int i = 0; i < 4; ++i) {
        // Back-project corner into view space
        vec4 v = uFrustum.invProj * ndcCorners[i];
        v /= v.w;

        // Scale to near/far slice depth
        vec3 cNear = v.xyz * (viewZNear / v.z);
        vec3 cFar  = v.xyz * (viewZFar  / v.z);

        minBounds = min(minBounds, cNear);
        maxBounds = max(maxBounds, cNear);
        minBounds = min(minBounds, cFar);
        maxBounds = max(maxBounds, cFar);
    }
}

/* === AABB Cluster Intersection === */

bool SphereAABBIntersect(vec3 sphereCenter, float sphereRadius, vec3 aabbMin, vec3 aabbMax)
{
    vec3 closestPoint = clamp(sphereCenter, aabbMin, aabbMax);
    vec3 delta = sphereCenter - closestPoint;

    return dot(delta, delta) <= (sphereRadius * sphereRadius);
}

bool ConeAABBIntersect(vec3 coneApex, vec3 coneDir, float coneRange, float coneAngleCos, vec3 aabbMin, vec3 aabbMax)
{
    // Adapted according to Bart Wronski's method
    // SEE: https://bartwronski.com/2017/04/13/cull-that-cone/

    // Create bounding sphere around AABB
    vec3 aabbCenter = (aabbMin + aabbMax) * 0.5;
    vec3 aabbExtent = (aabbMax - aabbMin) * 0.5;
    float sphereRadius = length(aabbExtent);

    // Vector from cone apex to sphere center
    vec3 V = aabbCenter - coneApex;
    float VlenSq = dot(V, V);
    float V1len = dot(V, coneDir); // Projection on cone axis

    // Distance from sphere center to closest point on cone surface
    float coneSinAngle = sqrt(1.0 - coneAngleCos * coneAngleCos);
    float distanceClosestPoint = coneAngleCos * sqrt(VlenSq - V1len * V1len) - V1len * coneSinAngle;

    // Three culling tests
    bool angleCull = distanceClosestPoint > sphereRadius;
    bool frontCull = V1len > sphereRadius + coneRange;
    bool backCull = V1len < -sphereRadius;

    return !(angleCull || frontCull || backCull);
}

/* === Light Volume Test === */

bool OmniLightAffectsCluster(in Light light, vec3 clusterMin, vec3 clusterMax)
{
    vec3 lightViewPos = (uFrustum.view * vec4(light.position, 1.0)).xyz;
    return SphereAABBIntersect(lightViewPos, light.range, clusterMin, clusterMax);
}

bool SpotLightAffectsCluster(in Light light, vec3 clusterMin, vec3 clusterMax)
{
    vec3 lightViewPos = (uFrustum.view * vec4(light.position, 1.0)).xyz;
    vec3 lightViewDir = normalize((uFrustum.view * vec4(light.direction, 0.0)).xyz);

    // For very wide angles (> 80°), use a spherical test
    if (light.outerCutOff < 0.17) { // cos(80°) ~= 0.17
        return SphereAABBIntersect(lightViewPos, light.range, clusterMin, clusterMax);
    }

    return ConeAABBIntersect(lightViewPos, lightViewDir, light.range, light.outerCutOff, clusterMin, clusterMax);
}

/* === Program === */

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

void main()
{
    /* --- Calculate cluster coordinates and its index --- */

    uvec3 clusterCoord = uvec3(gl_GlobalInvocationID.xyz);
    if (any(greaterThanEqual(clusterCoord, uClusterCount))) {
        return;
    }

    uint clusterId = L_ClusterIndex(clusterCoord, uClusterCount);
    uint base = clusterId * uMaxLightsPerCluster;

    /* --- Calculate cluster bounds --- */

    vec3 clusterMin = vec3(0.0);
    vec3 clusterMax = vec3(0.0);
    ClusterBounds(clusterCoord, clusterMin, clusterMax);

    // Store AABB for this cluster (useful for later passes)
    sClusterAABBs[clusterId].minBounds = clusterMin;
    sClusterAABBs[clusterId].maxBounds = clusterMax;

    /* --- Count and collect lights in separate passes --- */

    uint numLights[NUM_LIGHT_TYPE] = uint[](0u, 0u, 0u);
    uint currentOffset = 0u;

    for (uint i = 0u; i < uNumLights; ++i)
    {
        Light light = sLights[i];

        // Layer culling
        if ((uFrustum.cullMask & light.layerMask) == 0u) {
            continue;
        }

        // Frustum culling
        bool affectsCluster = true;
        if (light.type == LIGHT_SPOT) affectsCluster = SpotLightAffectsCluster(light, clusterMin, clusterMax);
        if (light.type == LIGHT_OMNI) affectsCluster = OmniLightAffectsCluster(light, clusterMin, clusterMax);
        if (!affectsCluster) continue;

        // Add light to cluster and update per-type counters
        sIndices[base + currentOffset] = i;
        numLights[light.type]++;
        currentOffset++;

        // Break loop if cluster is full
        if (currentOffset >= uMaxLightsPerCluster) {
            break;
        }
    }

    /* --- Store counts per type --- */

    sClusters[clusterId] = uvec4(
        numLights[LIGHT_DIR],
        numLights[LIGHT_SPOT],
        numLights[LIGHT_OMNI],
        0u
    );
}
