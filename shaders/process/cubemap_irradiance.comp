/* cubemap_irradiance.comp -- Irradiance cubemap generation compute shader
 *
 * Copyright (c) 2025 Le Juez Victor
 *
 * This software is provided 'as-is', without any express or implied warranty.
 * For conditions of distribution and use, see accompanying LICENSE file.
 */

/* === Profile Specific === */

#ifdef GL_ES
precision highp float;
#endif

/* === Includes === */

#include "../include/math.glsl"

/* === Local Size === */

layout(local_size_x = 8, local_size_y = 8, local_size_z = 6) in;

/* === Samplers === */

layout(binding = 0) uniform samplerCube uTexCubemap;
layout(binding = 1, rgba16f) uniform writeonly imageCubeArray uTargetCubemap;

/* === Uniforms === */

layout(location = 0) uniform int uTargetIndex; // Destination cubemap index

/* === Helper Functions === */

vec3 GetDirection(ivec3 globalId, float size)
{
    vec2 uvc = (vec2(globalId.xy) + 0.5) / size;
    vec2 uv = fma(uvc, vec2(2.0), vec2(-1.0));
    switch(globalId.z) {
    case 0: return normalize(vec3( 1.0, -uv.y, -uv.x)); // +X
    case 1: return normalize(vec3(-1.0, -uv.y,  uv.x)); // -X
    case 2: return normalize(vec3( uv.x,  1.0,  uv.y)); // +Y
    case 3: return normalize(vec3( uv.x, -1.0, -uv.y)); // -Y
    case 4: return normalize(vec3( uv.x, -uv.y,  1.0)); // +Z
    case 5: return normalize(vec3(-uv.x, -uv.y, -1.0)); // -Z
    }
    return vec3(0.0);
}

/* === Program === */

void main()
{
    /* --- Check if we're within bounds --- */

    const float imgSize = float(imageSize(uTargetCubemap).x);
    ivec3 globalId = ivec3(gl_GlobalInvocationID.xyz);

    if (globalId.x >= int(imgSize) || globalId.y >= int(imgSize)) {
        return;
    }

    /* --- Calculate cubemap/face index in the texture array --- */

    int layer = uTargetIndex * 6 + globalId.z;

    /* --- Get the world space direction for this texel and build orthonormal basis --- */

    vec3 N = GetDirection(globalId, imgSize);
    mat3 OBN = M_OrthonormalBasis(N);

    /* --- Convolve environment map --- */

    vec3 irradiance = vec3(0.0);
    float sampleDelta = 0.025;
    float nrSamples = 0.0;

    for (float phi = 0.0; phi < 2.0 * M_PI; phi += sampleDelta)
    {
        for (float theta = 0.0; theta < 0.5 * M_PI; theta += sampleDelta)
        {
            vec3 tangentSample = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
            vec3 sampleVec = OBN * tangentSample;

            const float lod = 1.5; //< Use a slightly lower LOD to reduce aliasing
            irradiance += textureLod(uTexCubemap, sampleVec, lod).rgb * cos(theta) * sin(theta);
            nrSamples++;
        }
    }

    /* --- Normalize and store --- */

    irradiance = M_PI * irradiance * (1.0 / float(nrSamples));
    imageStore(uTargetCubemap, ivec3(globalId.xy, layer), vec4(irradiance, 1.0));
}
